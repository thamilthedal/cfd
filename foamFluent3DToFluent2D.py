# -*- coding: utf-8 -*-
"""
Created on Fri Jul  1 10:21:14 2022

@author: thamilmani
"""
import numpy as np


def foamFluent3DToFluent2D(inputFilename, outputFilename, nBoundaries, Z=0):
    """
    

    Parameters
    ----------
    inputFilename : STRING (ABC.msh)
        Input mesh file name of 3D mesh generated by OpenFoam.
    outputFilename : STRING (ABC.msh)
        Output mesh file name of 2D mesh for Fluent.
    nBoundaries : INTERGER
        Number of Boundaries defined in the blockmeshDict.
    Z : FLOAT, optional
        Default z value for the mesh. The default is 0.

    Returns
    -------
    None.

    """
    # Data Retrieval
    with open(inputFilename) as f:
        header = []
        for i in range(12):
            header.append(f.readline())

    header[10]

    pointSkip = 12

    nPoints = int(header[-2].split()[3], 16)

    pointsData = np.genfromtxt(
        inputFilename,
        skip_header=pointSkip,
        max_rows=nPoints,
    )

    with open(inputFilename) as f:
        faceHeader = f.readlines()[pointSkip + nPoints + 2]

    faceSkip = pointSkip + nPoints + 4

    nFaces = int(faceHeader.split()[3], 16)

    nAllFaces = nFaces

    faceData = np.genfromtxt(
        inputFilename,
        skip_header=faceSkip,
        max_rows=nFaces,
        dtype="int32",
        converters={_: lambda s: int(s, 16) for _ in range(7)},
    )

    boundarySkip = faceSkip + nFaces + 3
    headerSkip = faceSkip + nFaces + 1
    boundaryData = []
    boundaryHeader = [0] * nBoundaries
    for n in range(nBoundaries):
        with open(inputFilename) as f:
            boundaryHeader[n] = f.readlines()[headerSkip]

        nBoundaryFaces = (
            int(boundaryHeader[n].split()[3], 16) - int(boundaryHeader[n].split()[2], 16)
        ) + 1

        boundaryData.append(
            np.genfromtxt(
                inputFilename,
                skip_header=boundarySkip,
                max_rows=nBoundaryFaces,
                dtype="int32",
                converters={_: lambda s: int(s, 16) for _ in range(7)},
            )
        )
        headerSkip += nBoundaryFaces + 3
        boundarySkip += nBoundaryFaces + 3
        nAllFaces += nBoundaryFaces

    nodeSkip = boundarySkip + 1 + (int(header[-4].split()[3], 16) - nAllFaces)
    with open(inputFilename) as f:
        nodeHeader = f.readlines()[nodeSkip]

    # Getting Footer
    footerSkip = nodeSkip + 2
    footer = []
    with open(inputFilename) as f:
        for line in f.readlines()[footerSkip:-1]:
            footer.append(line)

    # Data Writing
    with open(outputFilename, "w") as g:

        # Writing Header with changes to 2D
        a = '(0 "FOAM to 2D Fluent Mesh File") \n \n'
        g.write(a)
        g.write(header[2])
        g.write("(2 2) \n \n")

        y = str(hex(int(nPoints / 2))).replace("0x", "")
        x = header[6].replace(header[6].split()[3], y, 1)

        g.write(x.replace("3", "2", 1))
        x = header[-2].replace(header[-2].split()[3], y, 1)

        g.write(x.replace("3", "2", 1))

        g.write("( \n")

        # Writing Points into the mesh
        for i in range(int(nPoints)):
            if pointsData[i, 2] == Z:
                c = "\t {} {}\n".format(pointsData[i, 0], pointsData[i, 1])
                g.write(c)
        g.write(")) \n")

        y = str(hex(nAllFaces)).replace("0x", "")
        z = header[-4].replace(header[-4].split()[3], y)
        g.write(z)
        a = '(0 "Interior Faces") \n \n'
        g.write(a)
        # Writing Face Header
        g.write(faceHeader.replace("0", "2", 1))
        g.write("( \n")

        # Writing Internal Faces into the mesh

        # Face IDs for conversion
        faceDataCount = []
        for i in range(nFaces):
            count = 0
            ID = []
            for j in range(1, 5):
                if faceData[i, j] > nPoints / 2:
                    continue
                else:
                    ID.append(j)
            if ID == [1, 4]:
                [A, B] = ID
            else:
                [B, A] = ID
            P = str(hex(faceData[i, A])).replace("0x", "")
            Q = str(hex(faceData[i, B])).replace("0x", "")
            R = str(hex(faceData[i, 5])).replace("0x", "")
            S = str(hex(faceData[i, 6])).replace("0x", "")
            c = "\t {} {} {} {}\n".format(P, Q, R, S)
            g.write(c)
        g.write(")) \n")

        # Writing Boundary Faces into the mesh
        for n in range(nBoundaries):

            # Writing Boundary Face Header
            g.write(boundaryHeader[n].replace("0", "2", 1))
            g.write("( \n")
            # Writing Boundary Faces into the mesh

            # Boundary Face IDs for conversion
            for i in range(nBoundaryFaces):
                ID = []
                for j in range(1, 5):
                    if boundaryData[n][i, j] > nPoints / 2:
                        continue
                    else:
                        ID.append(j)
                if ID == [1, 4]:
                    [A, B] = ID
                else:
                    [B, A] = ID
                P = str(hex(boundaryData[n][i, A])).replace("0x", "")
                Q = str(hex(boundaryData[n][i, B])).replace("0x", "")
                R = str(hex(boundaryData[n][i, 5])).replace("0x", "")
                S = str(hex(boundaryData[n][i, 6])).replace("0x", "")
                c = "\t {} {} {} {}\n".format(P, Q, R, S)
                g.write(c)
            g.write(")) \n")

        g.write(header[7])

        string = nodeHeader.replace("0", "3", 1)
        index = string.rfind("(")
        new_character = ")"
        nodeHeader = string[:index] + new_character + string[index + 1 :]
        g.write(nodeHeader)
        for s in footer:
            g.write(s)


if __name__ == "__main__":

    inputFilename = "cavity.msh"
    outputFilename = "test.msh"
    nBoundaries = 4
    foamFluent3DToFluent2D(inputFilename, outputFilename, nBoundaries)
